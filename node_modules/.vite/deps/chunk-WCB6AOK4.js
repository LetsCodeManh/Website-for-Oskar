import {
  require_react
} from "./chunk-FWPJRZBE.js";
import {
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/hero-slider/dist/HeroSlider.js
var import_react10 = __toESM(require_react());

// node_modules/hero-slider/dist/node_modules/.pnpm/style-inject@0.3.0/node_modules/style-inject/dist/style-inject.es.js
function styleInject(css, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

// node_modules/hero-slider/dist/HeroSlider.module.css.js
var css_248z = ".HeroSlider-module_Wrapper__TaeBr {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n  /* Removes gray highlight when clicked on safari/mobile. */\n  -webkit-tap-highlight-color: rgba(0,0,0,0);\n  animation: HeroSlider-module_fade-in__5as8N var(--slider-fade-in-duration, 100) ease-in;\n}\n\n@keyframes HeroSlider-module_fade-in__5as8N {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n.HeroSlider-module_Container__EBtOP {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 2;\n  pointer-events: none;\n}\n\n/* `pointer-events` manipulation to allow clicking inner children AND children inside the Container. */\n.HeroSlider-module_Container__EBtOP * {\n  pointer-events: auto;\n}\n\n/**\n* ------------------------------------\n* ----------ANIMATIONS----------------\n* ------------------------------------\n*/\n\n.HeroSlider-module_Sliding_Fade_In__mRgKX {\n  /* keyframe name | duration | timing function | delay */\n  animation: HeroSlider-module_slide-fade-in__s5eQJ var(--sliding-duration, 600ms) ease-in-out var(--sliding-delay, 0ms);\n}\n\n@keyframes HeroSlider-module_slide-fade-in__s5eQJ {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n.HeroSlider-module_Sliding_Left_To_Right__XPZWw {\n  /* keyframe name | duration | timing function | delay */\n  animation: HeroSlider-module_slide-left-to-right__mPnzQ var(--sliding-duration, 600ms) ease-in-out var(--sliding-delay, 0ms);\n}\n\n@keyframes HeroSlider-module_slide-left-to-right__mPnzQ {\n  0% {\n    clip-path: inset(0% 100% 0% 0%);\n    -webkit-clip-path: inset(0% 100% 0% 0%);\n  }\n  100% {\n    clip-path: inset(0% 0% 0% 0%);\n    -webkit-clip-path: inset(0% 0% 0% 0%);\n  }\n}\n\n.HeroSlider-module_Sliding_Right_To_Left__62-PD {\n  /* keyframe name | duration | timing function | delay */\n  animation: HeroSlider-module_slide-right-to-left__qlxI2 var(--sliding-duration, 600ms) ease-in-out var(--sliding-delay, 0ms);\n}\n\n@keyframes HeroSlider-module_slide-right-to-left__qlxI2 {\n  0% {\n    clip-path: inset(0% 0% 0% 100%);\n    -webkit-clip-path: inset(0% 0% 0% 100%);\n  }\n  100% {\n    clip-path: inset(0% 0% 0% 0%);\n    -webkit-clip-path: inset(0% 0% 0% 0%);\n  }\n}\n\n.HeroSlider-module_Sliding_Top_To_Bottom__9qXf- {\n  /* keyframe name | duration | timing function | delay */\n  animation: HeroSlider-module_slide-top-to-bottom__2AGIn var(--sliding-duration, 600ms) ease-in-out var(--sliding-delay, 0ms);\n}\n\n@keyframes HeroSlider-module_slide-top-to-bottom__2AGIn {\n  0% {\n    clip-path: inset(0% 0% 100% 0%);\n    -webkit-clip-path: inset(0% 0% 100% 0%);\n  }\n  100% {\n    clip-path: inset(0% 0% 0% 0%);\n    -webkit-clip-path: inset(0% 0% 0% 0%);\n  }\n}\n\n.HeroSlider-module_Sliding_Bottom_To_Top__fuFNk {\n  /* keyframe name | duration | timing function | delay */\n  animation: HeroSlider-module_slide-bottom-to-top__fkZ3m var(--sliding-duration, 600ms) ease-in-out var(--sliding-delay, 0ms);\n}\n\n@keyframes HeroSlider-module_slide-bottom-to-top__fkZ3m {\n  0% {\n    clip-path: inset(100% 0% 0% 0%);\n    -webkit-clip-path: inset(100% 0% 0% 0%);\n  }\n  100% {\n    clip-path: inset(0% 0% 0% 0%);\n    -webkit-clip-path: inset(0% 0% 0% 0%);\n  }\n}\n";
var HeroSliderModuleCss = { "Wrapper": "HeroSlider-module_Wrapper__TaeBr", "fade-in": "HeroSlider-module_fade-in__5as8N", "Container": "HeroSlider-module_Container__EBtOP", "Sliding_Fade_In": "HeroSlider-module_Sliding_Fade_In__mRgKX", "slide-fade-in": "HeroSlider-module_slide-fade-in__s5eQJ", "Sliding_Left_To_Right": "HeroSlider-module_Sliding_Left_To_Right__XPZWw", "slide-left-to-right": "HeroSlider-module_slide-left-to-right__mPnzQ", "Sliding_Right_To_Left": "HeroSlider-module_Sliding_Right_To_Left__62-PD", "slide-right-to-left": "HeroSlider-module_slide-right-to-left__qlxI2", "Sliding_Top_To_Bottom": "HeroSlider-module_Sliding_Top_To_Bottom__9qXf-", "slide-top-to-bottom": "HeroSlider-module_slide-top-to-bottom__2AGIn", "Sliding_Bottom_To_Top": "HeroSlider-module_Sliding_Bottom_To_Top__fuFNk", "slide-bottom-to-top": "HeroSlider-module_slide-bottom-to-top__fkZ3m" };
styleInject(css_248z);

// node_modules/hero-slider/dist/components/Buttons/index.js
var import_react4 = __toESM(require_react());

// node_modules/hero-slider/dist/components/Buttons/index.module.css.js
var css_248z2 = ".index-module_Wrapper__ZIVLd {\n  position: absolute;\n  z-index: 3;\n}\n\n@media (max-width: 744px) {\n  .index-module_Wrapper__ZIVLd {\n    display: none;\n  }\n}\n\n.index-module_Wrapper__ZIVLd,\n.index-module_Wrapper__ZIVLd * {\n  /* To disable double-tap zoom */\n  touch-action: manipulation;\n  pointer-events: none;\n}\n\n.index-module_Container__mtjRh {\n  position: absolute;\n  display: block;\n  height: 100%;\n  width: 100%;\n  top: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-shadow: none;\n  transition: all 400ms;\n  pointer-events: none;\n  will-change: transform;\n}\n\n/* `pointer-events` manipulation to allow clicking inner children AND children inside the Container. */\n.index-module_Wrapper__ZIVLd *:not(.index-module_Container__mtjRh),\n.index-module_Container__mtjRh * {\n  pointer-events: auto;\n}\n\n.index-module_Button__hkx4Z {\n  width: 100%;\n  /* Disabling button styling */\n  background: none;\n	color: inherit;\n	border: none;\n	padding: 0;\n	font: inherit;\n	cursor: pointer;\n	outline: inherit;\n}\n\n.index-module_Button__hkx4Z svg {\n  opacity: 0.5;\n  width: 60px;\n  height: 60px;\n  transition: all 200ms ease-in-out;\n  color: #FFF; \n}\n\n.index-module_Button__hkx4Z:hover svg {\n  opacity: 1;\n  width: 80px;\n  height: 80px;\n  color: #FFF; \n}\n\n/**\n* --------------------------------------\n* -------------HORIZONTAL---------------\n* --------------------------------------\n*/\n\n.index-module_Horizontal__8-P70.index-module_Wrapper__ZIVLd {\n  top: 0;\n  width: 20%;\n  height: 100%;\n  min-width: 45px;\n  max-width: 120px;\n}\n\n.index-module_Horizontal__8-P70.index-module_Previous__TaJVT {\n  left: 0;\n}\n\n.index-module_Horizontal__8-P70.index-module_Next__sFCHR {\n  right: 0;\n}\n\n.index-module_Horizontal__8-P70 .index-module_Container__mtjRh:hover {\n  --shadow: 100%;\n}\n\n.index-module_Horizontal__8-P70.index-module_Previous__TaJVT .index-module_Container__mtjRh {\n  left: 33%;\n  transform: translateX(-50%) scaleX(-1);\n  background: linear-gradient(\n    90deg,\n    var(--c1, transparent) 40%,\n    var(--c2, rgb(37, 37, 37, .05)) 60%,\n    var(--c3, rgb(37, 37, 37, 0.5)) 85%\n  ) var(--shadow, 0) / 200%;\n}\n\n.index-module_Horizontal__8-P70.index-module_Next__sFCHR .index-module_Container__mtjRh {\n  right: 33%;\n  transform: translateX(50%);\n  background: linear-gradient(\n    90deg,\n    var(--c1, transparent) 40%,\n    var(--c2, rgb(37, 37, 37, .05)) 60%,\n    var(--c3, rgb(37, 37, 37, 0.5)) 85%\n  ) var(--shadow, 0) / 200%;\n}\n\n/**\n* ------------------------------------\n* -------------VERTICAL---------------\n* ------------------------------------\n*/\n\n.index-module_Vertical__VyL0Y.index-module_Wrapper__ZIVLd {\n  width: 100%;\n  height: 15%;\n  max-height: 200px;\n}\n\n.index-module_Vertical__VyL0Y.index-module_Previous__TaJVT {\n  top: 0;\n}\n\n.index-module_Vertical__VyL0Y.index-module_Next__sFCHR {\n  bottom: 0;\n}\n\n.index-module_Vertical__VyL0Y .index-module_Container__mtjRh:hover {\n  --shadow: 0;\n}\n\n.index-module_Vertical__VyL0Y.index-module_Previous__TaJVT .index-module_Container__mtjRh {\n  background: linear-gradient(to bottom,\n    rgb(37, 37, 37, 0.66) 0%,\n    rgb(37, 37, 37, 0.33) 50%,\n    rgb(37, 37, 37, 0.15) 75%,\n    rgb(37, 37, 37, 0.01) 100%) no-repeat 0px var(--shadow, -200px);\n}\n\n.index-module_Vertical__VyL0Y.index-module_Previous__TaJVT svg {\n  transform: rotate(-90deg);\n}\n\n.index-module_Vertical__VyL0Y.index-module_Next__sFCHR .index-module_Container__mtjRh {\n  background: linear-gradient(to top,\n    rgb(37, 37, 37, 0.66) 0%,\n    rgb(37, 37, 37, 0.33) 50%,\n    rgb(37, 37, 37, 0.15) 75%,\n    rgb(37, 37, 37, 0.01) 100%) no-repeat 0px var(--shadow, 200px);\n}\n\n.index-module_Vertical__VyL0Y.index-module_Next__sFCHR svg {\n  transform: rotate(90deg);\n}\n";
var ButtonsModuleCss = { "Wrapper": "index-module_Wrapper__ZIVLd", "Container": "index-module_Container__mtjRh", "Button": "index-module_Button__hkx4Z", "Horizontal": "index-module_Horizontal__8-P70", "Previous": "index-module_Previous__TaJVT", "Next": "index-module_Next__sFCHR", "Vertical": "index-module_Vertical__VyL0Y" };
styleInject(css_248z2);

// node_modules/hero-slider/dist/modules/Manager.js
var import_react = __toESM(require_react());
function isMobile() {
  const isBrowser = typeof window !== "undefined";
  if (isBrowser) {
    if (navigator && /Mobi|Android/i.test(navigator.userAgentData || navigator.userAgent))
      return true;
    else
      return false;
  }
  return false;
}
var defaultProps = {
  isMobile: isMobile()
};
var ManagerStateContext = import_react.default.createContext(void 0);
function managerReducer(state, action) {
  switch (action.type) {
    case "update-is-mobile": {
      return Object.assign(Object.assign({}, state), { isMobile: state.isMobile });
    }
    case "register-slide": {
      const { slides } = state;
      slides.set(action.payload.ref, {
        ref: action.payload.ref,
        number: slides.size + 1,
        label: action.payload.label
      });
      return { isMobile: state.isMobile, slides, totalSlides: slides.size };
    }
    case "remove-slide": {
      const { slides } = state;
      slides.delete(action.payload);
      return { isMobile: state.isMobile, slides, totalSlides: slides.size };
    }
    default: {
      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
    }
  }
}
function ManagerProvider({ children, manager }) {
  var _a;
  const [state, dispatch] = import_react.default.useReducer(managerReducer, {
    isMobile: (_a = manager === null || manager === void 0 ? void 0 : manager.isMobile) !== null && _a !== void 0 ? _a : defaultProps.isMobile,
    slides: /* @__PURE__ */ new Map(),
    totalSlides: 0
  });
  const getSlide = (ref) => {
    return state.slides.get(ref);
  };
  const registerSlide = (ref, label) => {
    dispatch({
      type: "register-slide",
      payload: {
        ref,
        label
      }
    });
  };
  const removeSlide = (ref) => {
    dispatch({
      type: "remove-slide",
      payload: ref
    });
  };
  import_react.default.useEffect(() => {
    if (typeof (manager === null || manager === void 0 ? void 0 : manager.isMobile) === "boolean")
      dispatch({
        type: "update-is-mobile",
        payload: manager === null || manager === void 0 ? void 0 : manager.isMobile
      });
  }, [manager === null || manager === void 0 ? void 0 : manager.isMobile]);
  const value = { state, getSlide, registerSlide, removeSlide };
  return import_react.default.createElement(ManagerStateContext.Provider, { value }, children);
}
function useManager() {
  const context = import_react.default.useContext(ManagerStateContext);
  if (context === void 0) {
    throw new Error("useManager must be used within a ManagerProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/modules/Accessability.js
var import_react3 = __toESM(require_react());

// node_modules/hero-slider/dist/modules/Controller.js
var import_react2 = __toESM(require_react());
var defaultProps2 = {
  slidingDuration: 500,
  slidingDelay: 200,
  initialSlide: 1
};
var ControllerStateContext = import_react2.default.createContext(void 0);
function settingsReducer(state, action) {
  switch (action.type) {
    case "start-sliding": {
      return Object.assign(Object.assign({}, state), { isSliding: true, activeSlide: action.payload.nextSlide, prevActiveSlide: state.activeSlide, slidingDirection: action.payload.slidingDirection });
    }
    case "finish-sliding": {
      return Object.assign(Object.assign({}, state), { isSliding: false, slidingDirection: void 0 });
    }
    case "set-delay-timeout": {
      return Object.assign(Object.assign({}, state), { delayTimeout: action.payload });
    }
    case "set-sliding-timeout": {
      return Object.assign(Object.assign({}, state), { slidingTimeout: action.payload });
    }
    default: {
      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
    }
  }
}
function ControllerProvider({ children, controller }) {
  var _a, _b;
  const params = {
    slidingDuration: (_a = controller === null || controller === void 0 ? void 0 : controller.slidingDuration) !== null && _a !== void 0 ? _a : defaultProps2.slidingDuration,
    slidingDelay: (_b = controller === null || controller === void 0 ? void 0 : controller.slidingDelay) !== null && _b !== void 0 ? _b : defaultProps2.slidingDelay,
    initialSlide: (controller === null || controller === void 0 ? void 0 : controller.initialSlide) || defaultProps2.initialSlide
  };
  const [state, dispatch] = import_react2.default.useReducer(settingsReducer, {
    activeSlide: params.initialSlide,
    prevActiveSlide: 0,
    isSliding: false,
    slidingDirection: void 0,
    delayTimeout: void 0,
    slidingTimeout: void 0
  });
  const { state: manager } = useManager();
  const getNextSlide = (aSlide = state.activeSlide) => {
    const lastSlide = manager.totalSlides;
    const isNotLastSlide = aSlide <= lastSlide - 1;
    let nextSlide;
    if (isNotLastSlide)
      nextSlide = aSlide + 1;
    else
      nextSlide = 1;
    return nextSlide;
  };
  const getPreviousSlide = (aSlide = state.activeSlide) => {
    const lastSlide = manager.totalSlides;
    const isNotFirstSlide = aSlide > 1;
    let nextSlide;
    if (isNotFirstSlide)
      nextSlide = aSlide - 1;
    else
      nextSlide = lastSlide;
    return nextSlide;
  };
  const getSlidingCycleDuration = () => {
    return (params.slidingDuration + params.slidingDelay) * 1.1;
  };
  const changeSlide = (nextSlide, slidingDirection) => {
    if (state.isSliding)
      return;
    if (controller === null || controller === void 0 ? void 0 : controller.onBeforeSliding)
      controller.onBeforeSliding(state.activeSlide, nextSlide);
    dispatch({
      type: "start-sliding",
      payload: {
        nextSlide,
        slidingDirection
      }
    });
  };
  const goToNextSlide = () => {
    changeSlide(getNextSlide(state.activeSlide), "forward");
  };
  const goToPreviousSlide = () => {
    changeSlide(getPreviousSlide(state.activeSlide), "backward");
  };
  import_react2.default.useEffect(() => {
    if (controller === null || controller === void 0 ? void 0 : controller.goToNextSlidePointer)
      controller.goToNextSlidePointer.current = goToNextSlide;
  }, [controller === null || controller === void 0 ? void 0 : controller.goToNextSlidePointer, goToNextSlide]);
  import_react2.default.useEffect(() => {
    if (controller === null || controller === void 0 ? void 0 : controller.goToPreviousSlidePointer)
      controller.goToPreviousSlidePointer.current = goToPreviousSlide;
  }, [controller === null || controller === void 0 ? void 0 : controller.goToPreviousSlidePointer, goToNextSlide]);
  import_react2.default.useEffect(() => {
    dispatch({
      type: "set-delay-timeout",
      payload: setTimeout(() => {
        if (controller === null || controller === void 0 ? void 0 : controller.onSliding)
          controller.onSliding(state.activeSlide, state.prevActiveSlide);
      }, params.slidingDelay)
    });
    dispatch({
      type: "set-sliding-timeout",
      payload: setTimeout(() => {
        dispatch({ type: "finish-sliding" });
        if (controller === null || controller === void 0 ? void 0 : controller.onAfterSliding)
          controller.onAfterSliding(state.activeSlide, state.prevActiveSlide);
      }, getSlidingCycleDuration())
    });
    return () => {
      if (state.delayTimeout)
        clearTimeout(state.delayTimeout);
      if (state.slidingTimeout)
        clearTimeout(state.slidingTimeout);
    };
  }, [state.activeSlide]);
  const value = {
    state,
    slidingDuration: params.slidingDuration,
    slidingDelay: params.slidingDelay,
    getNextSlide,
    getPreviousSlide,
    getSlidingCycleDuration,
    changeSlide,
    goToNextSlide,
    goToPreviousSlide
  };
  return import_react2.default.createElement(ControllerStateContext.Provider, { value }, children);
}
function useController() {
  const context = import_react2.default.useContext(ControllerStateContext);
  if (context === void 0) {
    throw new Error("useController must be used within a ControllerProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/modules/Accessability.js
var AccessabilityOrientation;
(function(AccessabilityOrientation2) {
  AccessabilityOrientation2["VERTICAL"] = "vertical";
  AccessabilityOrientation2["HORIZONTAL"] = "horizontal";
})(AccessabilityOrientation || (AccessabilityOrientation = {}));
var defaultProps3 = {
  shouldDisplayButtons: true,
  shouldSlideOnArrowKeypress: true,
  orientation: AccessabilityOrientation.HORIZONTAL,
  thresholdToSlide: 50
};
var AccessabilityStateContext = import_react3.default.createContext(void 0);
function accessabilityReducer(state, action) {
  switch (action.type) {
    case "start-motion": {
      return {
        initialX: action.payload.x,
        initialY: action.payload.y,
        currentX: void 0,
        currentY: void 0
      };
    }
    case "update-motion": {
      return {
        initialX: state.initialX,
        initialY: state.initialY,
        currentX: action.payload.x,
        currentY: action.payload.y
      };
    }
    case "end-motion": {
      return {
        initialX: void 0,
        initialY: void 0,
        currentX: void 0,
        currentY: void 0
      };
    }
    default: {
      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
    }
  }
}
function AccessabilityProvider({ children, accessability }) {
  var _a, _b, _c;
  const params = {
    shouldDisplayButtons: (_a = accessability === null || accessability === void 0 ? void 0 : accessability.shouldDisplayButtons) !== null && _a !== void 0 ? _a : defaultProps3.shouldDisplayButtons,
    shouldSlideOnArrowKeypress: (_b = accessability === null || accessability === void 0 ? void 0 : accessability.shouldSlideOnArrowKeypress) !== null && _b !== void 0 ? _b : defaultProps3.shouldSlideOnArrowKeypress,
    orientation: (accessability === null || accessability === void 0 ? void 0 : accessability.orientation) || defaultProps3.orientation,
    thresholdToSlide: (_c = accessability === null || accessability === void 0 ? void 0 : accessability.thresholdToSlide) !== null && _c !== void 0 ? _c : defaultProps3.thresholdToSlide
  };
  const [state, dispatch] = import_react3.default.useReducer(accessabilityReducer, {
    initialX: void 0,
    initialY: void 0,
    currentX: void 0,
    currentY: void 0
  });
  const { goToNextSlide, goToPreviousSlide } = useController();
  const onTouchStartHandler = (event) => {
    dispatch({
      type: "start-motion",
      payload: {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      }
    });
  };
  const onTouchMoveHandler = (event) => {
    dispatch({
      type: "update-motion",
      payload: {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      }
    });
  };
  const onTouchEndHandler = () => {
    const diffX = Number(state.initialX) - Number(state.currentX);
    const diffY = Number(state.initialY) - Number(state.currentY);
    const isSlidingHorizontally = Math.abs(diffX) > Math.abs(diffY);
    const isSliderSetHorizontally = params.orientation === AccessabilityOrientation.HORIZONTAL;
    const isSliderVertically = params.orientation === AccessabilityOrientation.VERTICAL;
    if (isSlidingHorizontally && isSliderSetHorizontally && Math.abs(diffX) >= params.thresholdToSlide) {
      const isSwipingRight = diffX > 0;
      if (isSwipingRight)
        goToNextSlide();
      else
        goToPreviousSlide();
    } else if (isSliderVertically && Math.abs(diffY) >= params.thresholdToSlide) {
      const isSwipingUp = diffY > 0;
      if (isSwipingUp)
        goToNextSlide();
      else
        goToPreviousSlide();
    }
    dispatch({ type: "end-motion" });
  };
  const onArrowKeypressHandler = (e) => {
    if (!params.shouldSlideOnArrowKeypress)
      return;
    const isHorizontal = params.orientation === AccessabilityOrientation.HORIZONTAL;
    switch (true) {
      case (isHorizontal && e.keyCode === 37):
        goToPreviousSlide();
        break;
      case (isHorizontal && e.keyCode === 39):
        goToNextSlide();
        break;
      case (!isHorizontal && e.keyCode === 38):
        goToPreviousSlide();
        break;
      case (!isHorizontal && e.keyCode === 40):
        goToNextSlide();
        break;
    }
  };
  import_react3.default.useEffect(() => {
    window.addEventListener("keydown", onArrowKeypressHandler);
    return () => {
      window.removeEventListener("keydown", onArrowKeypressHandler);
    };
  }, [onArrowKeypressHandler]);
  const value = {
    state,
    shouldDisplayButtons: params.shouldDisplayButtons,
    orientation: params.orientation,
    onTouchStartHandler,
    onTouchMoveHandler,
    onTouchEndHandler
  };
  return import_react3.default.createElement(AccessabilityStateContext.Provider, { value }, children);
}
function useAccessability() {
  const context = import_react3.default.useContext(AccessabilityStateContext);
  if (context === void 0) {
    throw new Error("useAccessability must be used within a AccessabilityProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/utils/composeCssClasses.js
function composeCssClasses(...classes) {
  return classes.filter((i) => {
    if (!i)
      return false;
    else if (typeof i === "string")
      return true;
    else if (typeof i.useIf === "boolean")
      return i.useIf;
    else
      return true;
  }).map((i) => {
    if (typeof i === "string")
      return i;
    else
      return i.className;
  }).join(" ");
}

// node_modules/hero-slider/dist/components/Buttons/index.js
function ArrowSvg() {
  return import_react4.default.createElement(
    "svg",
    { width: "60px", height: "60px", strokeWidth: "5", version: "1.1", viewBox: "0 0 129 129" },
    import_react4.default.createElement(
      "g",
      { fill: "currentColor" },
      import_react4.default.createElement("path", { d: "m40.4,121.3c-0.8,0.8-1.8,1.2-2.9,1.2s-2.1-0.4-2.9-1.2c-1.6-1.6-1.6-4.2 0-5.8l51-51-51-51c-1.6-1.6-1.6-4.2 0-5.8 1.6-1.6 4.2-1.6 5.8,0l53.9,53.9c1.6,1.6 1.6,4.2 0,5.8l-53.9,53.9z" })
    )
  );
}
function Buttons() {
  const { state: { isMobile: isMobile2 } } = useManager();
  const { orientation } = useAccessability();
  const { goToPreviousSlide, goToNextSlide } = useController();
  if (isMobile2)
    return null;
  const isHorizontal = orientation === AccessabilityOrientation.HORIZONTAL;
  return import_react4.default.createElement(
    import_react4.default.Fragment,
    null,
    import_react4.default.createElement(
      "div",
      { className: composeCssClasses("hero-slider-previous", ButtonsModuleCss.Previous, ButtonsModuleCss.Wrapper, { className: ButtonsModuleCss.Horizontal, useIf: isHorizontal }, { className: ButtonsModuleCss.Vertical, useIf: !isHorizontal }) },
      import_react4.default.createElement(
        "div",
        { className: composeCssClasses("hero-slider-previous-container", ButtonsModuleCss.Container) },
        import_react4.default.createElement(
          "button",
          { className: composeCssClasses("hero-slider-previous-button", ButtonsModuleCss.Button), onClick: goToPreviousSlide },
          import_react4.default.createElement(ArrowSvg, null)
        )
      )
    ),
    import_react4.default.createElement(
      "div",
      { className: composeCssClasses("hero-slider-next", ButtonsModuleCss.Next, ButtonsModuleCss.Wrapper, { className: ButtonsModuleCss.Horizontal, useIf: isHorizontal }, { className: ButtonsModuleCss.Vertical, useIf: !isHorizontal }) },
      import_react4.default.createElement(
        "div",
        { className: composeCssClasses("hero-slider-next-container", ButtonsModuleCss.Container) },
        import_react4.default.createElement(
          "button",
          { className: composeCssClasses("hero-slider-next-button", ButtonsModuleCss.Button), onClick: goToNextSlide },
          import_react4.default.createElement(ArrowSvg, null)
        )
      )
    )
  );
}

// node_modules/hero-slider/dist/modules/Settings.js
var import_react5 = __toESM(require_react());

// node_modules/hero-slider/dist/modules/ConsoleLogger.js
var ConsoleLogger = class {
  constructor(levels) {
    this.levels = levels;
  }
  log(...data) {
    if (this.levels.verbose)
      console.log(...data);
  }
  info(...data) {
    if (this.levels.info)
      console.info(...data);
  }
  debug(...data) {
    if (this.levels.debug)
      console.debug(...data);
  }
  warn(...data) {
    if (this.levels.warnings)
      console.warn(...data);
  }
  error(...data) {
    if (this.levels.errors)
      console.error(...data);
  }
  static new(levels = {
    verbose: false,
    info: false,
    debug: false,
    warnings: true,
    errors: true
  }) {
    if (!this.instance)
      this.instance = new ConsoleLogger(levels);
    else
      this.instance.levels = levels;
    return this.instance;
  }
};

// node_modules/hero-slider/dist/modules/Settings.js
var defaultProps4 = {
  sliderColor: "inherit",
  sliderStyle: {},
  navbarStyle: {
    color: void 0,
    activeColor: void 0
  }
};
var SettingsStateContext = import_react5.default.createContext(void 0);
function SettingsProvider({ children, settings }) {
  const params = {
    sliderColor: (settings === null || settings === void 0 ? void 0 : settings.sliderColor) || defaultProps4.sliderColor,
    sliderStyle: (settings === null || settings === void 0 ? void 0 : settings.sliderStyle) || defaultProps4.sliderStyle,
    navbarStyle: (settings === null || settings === void 0 ? void 0 : settings.navbarStyle) || defaultProps4.navbarStyle,
    debug: settings === null || settings === void 0 ? void 0 : settings.debug
  };
  import_react5.default.useEffect(() => {
    ConsoleLogger.new(params.debug);
  }, [params.debug]);
  const value = params;
  return import_react5.default.createElement(SettingsStateContext.Provider, { value }, children);
}
function useSettings() {
  const context = import_react5.default.useContext(SettingsStateContext);
  if (context === void 0) {
    throw new Error("useSettings must be used within a SettingsProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/modules/Animations.js
var import_react6 = __toESM(require_react());
var SlidingAnimation;
(function(SlidingAnimation2) {
  SlidingAnimation2["TOP_TO_BOTTOM"] = "top_to_bottom";
  SlidingAnimation2["BOTTOM_TO_TOP"] = "bottom_to_top";
  SlidingAnimation2["LEFT_TO_RIGHT"] = "left_to_right";
  SlidingAnimation2["RIGHT_TO_LEFT"] = "right_to_left";
  SlidingAnimation2["FADE"] = "fade";
})(SlidingAnimation || (SlidingAnimation = {}));
var SlidingAnimationCssClassMap = {
  [SlidingAnimation.FADE]: HeroSliderModuleCss.Sliding_Fade_In,
  [SlidingAnimation.TOP_TO_BOTTOM]: HeroSliderModuleCss.Sliding_Top_To_Bottom,
  [SlidingAnimation.BOTTOM_TO_TOP]: HeroSliderModuleCss.Sliding_Bottom_To_Top,
  [SlidingAnimation.LEFT_TO_RIGHT]: HeroSliderModuleCss.Sliding_Left_To_Right,
  [SlidingAnimation.RIGHT_TO_LEFT]: HeroSliderModuleCss.Sliding_Right_To_Left
};
var defaultProps5 = {
  slidingAnimation: "wipe",
  sliderFadeInDuration: 100,
  navbarFadeInDuration: 1e3,
  navbarFadeInDelay: 500,
  shouldManageAnimationSequence: true
};
var AnimationsStateContext = import_react6.default.createContext(void 0);
function AnimationsProvider({ children, animations }) {
  var _a, _b, _c, _d;
  const { orientation } = useAccessability();
  const params = {
    slidingAnimation: (animations === null || animations === void 0 ? void 0 : animations.slidingAnimation) || defaultProps5.slidingAnimation,
    sliderFadeInDuration: (_a = animations === null || animations === void 0 ? void 0 : animations.sliderFadeInDuration) !== null && _a !== void 0 ? _a : defaultProps5.sliderFadeInDuration,
    navbarFadeInDuration: (_b = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDuration) !== null && _b !== void 0 ? _b : defaultProps5.navbarFadeInDuration,
    navbarFadeInDelay: (_c = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDelay) !== null && _c !== void 0 ? _c : defaultProps5.navbarFadeInDelay,
    shouldManageAnimationSequence: (_d = animations === null || animations === void 0 ? void 0 : animations.shouldManageAnimationSequence) !== null && _d !== void 0 ? _d : defaultProps5.shouldManageAnimationSequence
  };
  const getSlidingAnimationCssClass = (activeSlide, prevActiveSlide, slidingDirection) => {
    const getSlidingAnimation = () => {
      switch (params.slidingAnimation) {
        case "fade":
          return SlidingAnimation.FADE;
        case "wipe": {
          let direction;
          if (slidingDirection)
            direction = slidingDirection;
          else {
            const isSlidingForward = activeSlide > prevActiveSlide;
            direction = isSlidingForward ? "forward" : "backward";
          }
          if (direction === "forward")
            return orientation === AccessabilityOrientation.HORIZONTAL ? SlidingAnimation.RIGHT_TO_LEFT : SlidingAnimation.BOTTOM_TO_TOP;
          else
            return orientation === AccessabilityOrientation.HORIZONTAL ? SlidingAnimation.LEFT_TO_RIGHT : SlidingAnimation.TOP_TO_BOTTOM;
        }
        default: {
          throw new Error(`Unhandled sliding animation: [${params.slidingAnimation}]`);
        }
      }
    };
    return SlidingAnimationCssClassMap[getSlidingAnimation()];
  };
  const value = {
    sliderFadeInDuration: params.sliderFadeInDuration,
    navbarFadeInDuration: params.sliderFadeInDuration,
    navbarFadeInDelay: params.sliderFadeInDuration,
    getSlidingAnimationCssClass
  };
  return import_react6.default.createElement(AnimationsStateContext.Provider, { value }, children);
}
function useAnimations() {
  const context = import_react6.default.useContext(AnimationsStateContext);
  if (context === void 0) {
    throw new Error("useAnimations must be used within a AnimationsProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/modules/Layout.js
var import_react7 = __toESM(require_react());
var mobileThreshold = 1024;
var LayoutStateContext = import_react7.default.createContext(void 0);
function layoutReducer(state, action) {
  var _a, _b;
  switch (action.type) {
    case "update-slider-dimensions": {
      return {
        slider: state.slider,
        width: (_a = state.slider.current) === null || _a === void 0 ? void 0 : _a.clientWidth,
        height: (_b = state.slider.current) === null || _b === void 0 ? void 0 : _b.clientHeight
      };
    }
    default: {
      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
    }
  }
}
function LayoutProvider({ children }) {
  const [state, dispatch] = import_react7.default.useReducer(layoutReducer, {
    slider: import_react7.default.useRef(null),
    width: void 0,
    height: void 0
  });
  import_react7.default.useEffect(() => {
    function updateSliderDimensions() {
      if (state.slider.current)
        dispatch({ type: "update-slider-dimensions" });
    }
    updateSliderDimensions();
    window.addEventListener("resize", updateSliderDimensions);
    return () => {
      window.removeEventListener("resize", updateSliderDimensions);
    };
  }, [state.slider.current]);
  const value = { state, mobileThreshold };
  return import_react7.default.createElement(LayoutStateContext.Provider, { value }, children);
}
function useLayout() {
  const context = import_react7.default.useContext(LayoutStateContext);
  if (context === void 0) {
    throw new Error("useLayout must be used within a LayoutProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/modules/Autoplay.js
var import_react9 = __toESM(require_react());

// node_modules/hero-slider/dist/modules/IntervalTimer.js
var IntervalState;
(function(IntervalState2) {
  IntervalState2[IntervalState2["IDLE"] = 0] = "IDLE";
  IntervalState2[IntervalState2["RUNNING"] = 1] = "RUNNING";
  IntervalState2[IntervalState2["PAUSED"] = 2] = "PAUSED";
  IntervalState2[IntervalState2["RESUME"] = 3] = "RESUME";
})(IntervalState || (IntervalState = {}));
var IntervalTimer = class {
  constructor(callback, interval, maxFires) {
    this.callback = callback;
    this.interval = interval;
    this.maxFires = maxFires;
    this.state = IntervalState.IDLE;
    this.remaining = 0;
    this.fires = 0;
    this.pausedTime = 0;
    this.intervalHandler = () => {
      if (this.maxFires != null && this.fires !== 0 && this.fires >= this.maxFires) {
        this.stop();
      } else {
        this.lastTimeFired = new Date();
        this.fires += 1;
        this.callback();
      }
    };
    this.timeoutHandler = () => {
      if (this.state !== IntervalState.RESUME)
        return;
      this.pausedTime = 0;
      this.intervalHandler();
      this.start();
    };
    this.start = () => {
      this.timerId = setInterval(this.intervalHandler, this.interval);
      this.lastTimeFired = new Date();
      this.state = IntervalState.RUNNING;
    };
    this.stop = () => {
      if (this.state === 0)
        return;
      clearInterval(this.timerId);
      clearTimeout(this.resumeId);
      this.state = IntervalState.IDLE;
    };
    this.reset = () => {
      this.stop();
      this.start();
    };
    this.pause = () => {
      if (this.state !== IntervalState.RUNNING && this.state !== IntervalState.RESUME)
        return;
      this.remaining = +this.interval - (+new Date() - +(this.lastTimeFired || 0)) + +this.pausedTime;
      this.lastPauseTime = new Date();
      clearInterval(this.timerId);
      clearTimeout(this.resumeId);
      this.state = IntervalState.PAUSED;
    };
    this.resume = () => {
      if (this.state !== IntervalState.PAUSED)
        return;
      const currentDate = new Date();
      this.pausedTime = +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);
      this.state = IntervalState.RESUME;
      this.resumeId = setTimeout(this.timeoutHandler, this.remaining);
    };
    this.setInterval = (newInterval) => {
      if (this.state === 1) {
        this.pause();
        this.interval = newInterval;
        this.resume();
      } else {
        this.interval = newInterval;
      }
    };
    this.setMaxFires = (newMax) => {
      if (newMax != null && this.fires >= newMax) {
        this.stop();
      }
      this.maxFires = newMax;
    };
  }
  static new(callback, interval, maxFires = void 0) {
    if (!this.instance)
      this.instance = new IntervalTimer(callback, interval, maxFires);
    else {
      this.instance.callback = callback;
      this.instance.interval = interval;
      this.instance.maxFires = maxFires;
    }
    return this.instance;
  }
};

// node_modules/hero-slider/dist/modules/IntersectionObserver.js
var import_react8 = __toESM(require_react());

// node_modules/hero-slider/dist/node_modules/.pnpm/react-intersection-observer@9.4.0_react@18.2.0/node_modules/react-intersection-observer/react-intersection-observer.modern.mjs.js
var React = __toESM(require_react());
var observerMap = /* @__PURE__ */ new Map();
var RootIds = /* @__PURE__ */ new WeakMap();
var rootId = 0;
var unsupportedValue = void 0;
function getRootId(root) {
  if (!root)
    return "0";
  if (RootIds.has(root))
    return RootIds.get(root);
  rootId += 1;
  RootIds.set(root, rootId.toString());
  return RootIds.get(root);
}
function optionsToId(options) {
  return Object.keys(options).sort().filter((key) => options[key] !== void 0).map((key) => {
    return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
  }).toString();
}
function createObserver(options) {
  let id = optionsToId(options);
  let instance = observerMap.get(id);
  if (!instance) {
    const elements = /* @__PURE__ */ new Map();
    let thresholds;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        var _elements$get;
        const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
        if (options.trackVisibility && typeof entry.isVisible === "undefined") {
          entry.isVisible = inView;
        }
        (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach((callback) => {
          callback(inView, entry);
        });
      });
    }, options);
    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance = {
      id,
      observer,
      elements
    };
    observerMap.set(id, instance);
  }
  return instance;
}
function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
  if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
    const bounds = element.getBoundingClientRect();
    callback(fallbackInView, {
      isIntersecting: fallbackInView,
      target: element,
      intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
      time: 0,
      boundingClientRect: bounds,
      intersectionRect: bounds,
      rootBounds: bounds
    });
    return () => {
    };
  }
  const {
    id,
    observer,
    elements
  } = createObserver(options);
  let callbacks = elements.get(element) || [];
  if (!elements.has(element)) {
    elements.set(element, callbacks);
  }
  callbacks.push(callback);
  observer.observe(element);
  return function unobserve() {
    callbacks.splice(callbacks.indexOf(callback), 1);
    if (callbacks.length === 0) {
      elements.delete(element);
      observer.unobserve(element);
    }
    if (elements.size === 0) {
      observer.disconnect();
      observerMap.delete(id);
    }
  };
}
function useInView({
  threshold,
  delay,
  trackVisibility,
  rootMargin,
  root,
  triggerOnce,
  skip,
  initialInView,
  fallbackInView,
  onChange
} = {}) {
  var _state$entry;
  const [ref, setRef] = React.useState(null);
  const callback = React.useRef();
  const [state, setState] = React.useState({
    inView: !!initialInView,
    entry: void 0
  });
  callback.current = onChange;
  React.useEffect(
    () => {
      if (skip || !ref)
        return;
      let unobserve = observe(ref, (inView, entry) => {
        setState({
          inView,
          entry
        });
        if (callback.current)
          callback.current(inView, entry);
        if (entry.isIntersecting && triggerOnce && unobserve) {
          unobserve();
          unobserve = void 0;
        }
      }, {
        root,
        rootMargin,
        threshold,
        trackVisibility,
        delay
      }, fallbackInView);
      return () => {
        if (unobserve) {
          unobserve();
        }
      };
    },
    [
      Array.isArray(threshold) ? threshold.toString() : threshold,
      ref,
      root,
      rootMargin,
      triggerOnce,
      skip,
      trackVisibility,
      fallbackInView,
      delay
    ]
  );
  const entryTarget = (_state$entry = state.entry) == null ? void 0 : _state$entry.target;
  React.useEffect(() => {
    if (!ref && entryTarget && !triggerOnce && !skip) {
      setState({
        inView: !!initialInView,
        entry: void 0
      });
    }
  }, [ref, entryTarget, triggerOnce, skip, initialInView]);
  const result = [setRef, state.inView, state.entry];
  result.ref = result[0];
  result.inView = result[1];
  result.entry = result[2];
  return result;
}

// node_modules/hero-slider/dist/modules/IntersectionObserver.js
var IntersectionObserverStateContext = import_react8.default.createContext(void 0);
function IntersectionObserverProvider({ children }) {
  const [ref, inView] = useInView({ threshold: 0 });
  const value = {
    elementObservedRef: ref,
    isInView: inView
  };
  return import_react8.default.createElement(IntersectionObserverStateContext.Provider, { value }, children);
}
function useIntersectionObserver() {
  const context = import_react8.default.useContext(IntersectionObserverStateContext);
  if (context === void 0) {
    throw new Error("useIntersectionObserver must be used within a IntersectionObserverProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/modules/Autoplay.js
var logger = ConsoleLogger.new();
var defaultProps6 = {
  autoplayDuration: 8e3,
  autoplayDebounce: 4e3
};
var AutoplayStateContext = import_react9.default.createContext(void 0);
function autoplayReducer(state, action) {
  switch (action.type) {
    case "pause": {
      return Object.assign(Object.assign({}, state), { isPausedByUser: true });
    }
    case "resume": {
      return Object.assign(Object.assign({}, state), { isPausedByUser: false });
    }
    case "set-debounce-timeout": {
      return Object.assign(Object.assign({}, state), { debounceTimeout: action.payload });
    }
    default: {
      throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
    }
  }
}
function AutoplayProvider({ children, autoplay }) {
  var _a, _b;
  const params = {
    autoplayDuration: (_a = typeof autoplay === "object" ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDuration : void 0) !== null && _a !== void 0 ? _a : defaultProps6.autoplayDuration,
    autoplayDebounce: (_b = typeof autoplay === "object" ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDebounce : void 0) !== null && _b !== void 0 ? _b : defaultProps6.autoplayDebounce
  };
  const [state, dispatch] = import_react9.default.useReducer(autoplayReducer, {
    isPausedByUser: false,
    debounceTimeout: void 0
  });
  const { state: controller, changeSlide, getNextSlide, getSlidingCycleDuration } = useController();
  const slidingCycleDuration = getSlidingCycleDuration();
  const autoplayCycleDuration = Math.max(slidingCycleDuration, params.autoplayDuration);
  if (params.autoplayDuration < getSlidingCycleDuration())
    logger.warn("[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).", "The sliding cycle duration will be used instead for the autoplay intervals.");
  const autoplayInstance = IntervalTimer.new(() => {
    changeSlide(getNextSlide(controller.activeSlide));
  }, autoplayCycleDuration);
  const { isInView } = useIntersectionObserver();
  const debounce = () => {
    const isPausedOrIdle = autoplayInstance.state === IntervalState.IDLE || state.isPausedByUser;
    if (isPausedOrIdle)
      return;
    autoplayInstance.pause();
    if (state.debounceTimeout)
      clearTimeout(state.debounceTimeout);
    dispatch({
      type: "set-debounce-timeout",
      payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)
    });
  };
  const pause = () => {
    logger.debug("[Autoplay] Paused by user.");
    autoplayInstance.pause();
    dispatch({ type: "pause" });
  };
  const resume = () => {
    logger.debug("[Autoplay] Resumed by user.");
    autoplayInstance.resume();
    dispatch({ type: "resume" });
  };
  import_react9.default.useEffect(() => {
    if (state.isPausedByUser)
      clearTimeout(state.debounceTimeout);
    return () => {
    };
  }, [state.isPausedByUser]);
  import_react9.default.useEffect(() => {
    if (autoplay) {
      switch (true) {
        case state.isPausedByUser:
          break;
        case (!isInView && autoplayInstance.state !== IntervalState.IDLE):
          autoplayInstance.stop();
          logger.debug("[Autoplay] Stopped.");
          break;
        case (isInView && autoplayInstance.state === IntervalState.IDLE): {
          autoplayInstance.start();
          logger.debug("[Autoplay] Started.");
          break;
        }
        case (isInView && autoplayInstance.state === IntervalState.PAUSED): {
          autoplayInstance.resume();
          logger.debug("[Autoplay] Resumed.");
          break;
        }
      }
    } else if (autoplayInstance.state !== IntervalState.IDLE) {
      autoplayInstance.stop();
      logger.info("[Autoplay] Stopped.");
    }
  }, [autoplay, isInView]);
  import_react9.default.useEffect(() => {
    return () => {
      clearTimeout(state.debounceTimeout);
      autoplayInstance.stop();
    };
  }, []);
  import_react9.default.useEffect(() => {
    clearTimeout(state.debounceTimeout);
    return () => {
    };
  }, [controller.activeSlide]);
  const value = {
    state,
    autoplayState: autoplayInstance.state,
    debounce,
    pause,
    resume
  };
  return import_react9.default.createElement(AutoplayStateContext.Provider, { value }, children);
}
function useAutoplay() {
  const context = import_react9.default.useContext(AutoplayStateContext);
  if (context === void 0) {
    throw new Error("useAutoplay must be used within a AutoplayProvider");
  }
  return context;
}

// node_modules/hero-slider/dist/HeroSlider.js
var logger2 = ConsoleLogger.new();
function Orchestrator({ className, width = "100%", height = "100vh", style, children }) {
  logger2.info("[Orchestrator] rerender");
  const { shouldDisplayButtons } = useAccessability();
  const { sliderFadeInDuration, navbarFadeInDuration, navbarFadeInDelay } = useAnimations();
  const { state: layout } = useLayout();
  const { slidingDuration, slidingDelay, getSlidingCycleDuration } = useController();
  const settings = useSettings();
  const { debounce } = useAutoplay();
  const { onTouchStartHandler, onTouchMoveHandler, onTouchEndHandler } = useAccessability();
  const { elementObservedRef } = useIntersectionObserver();
  const CSSVariables = {
    "--sliding-duration": `${slidingDuration}ms`,
    "--sliding-delay": `${slidingDelay}ms`,
    "--slide-transition-delay": `${getSlidingCycleDuration()}ms`,
    "--slider-width": layout.width ? `${layout.width}px` : void 0,
    "--slider-height": layout.height ? `${layout.height}px` : void 0,
    "--slider-color": settings.sliderColor,
    "--slider-fade-in-duration": `${sliderFadeInDuration}ms`,
    "--nav-fade-in-duration": `${navbarFadeInDuration}ms`,
    "--nav-fade-in-delay": `${navbarFadeInDelay}ms`,
    "--nav-background-color": settings.navbarStyle ? settings.navbarStyle.color : void 0,
    "--nav-active-color": settings.navbarStyle ? settings.navbarStyle.activeColor : void 0,
    "--mask-duration": `${getSlidingCycleDuration()}ms`
  };
  return import_react10.default.createElement(
    "div",
    { className: composeCssClasses("hero-slider-root", className), ref: elementObservedRef },
    import_react10.default.createElement(
      "div",
      { ref: layout.slider, className: composeCssClasses("hero-slider-wrapper", HeroSliderModuleCss.Wrapper), onTouchStart: onTouchStartHandler, onTouchMove: onTouchMoveHandler, onTouchEnd: onTouchEndHandler, onMouseMoveCapture: debounce, style: Object.assign(Object.assign(Object.assign({}, CSSVariables), style), { width, height }) },
      children,
      shouldDisplayButtons && import_react10.default.createElement(Buttons, null)
    )
  );
}
function HeroSlider(props) {
  return import_react10.default.createElement(
    LayoutProvider,
    null,
    import_react10.default.createElement(
      ManagerProvider,
      { manager: props.manager },
      import_react10.default.createElement(
        SettingsProvider,
        { settings: props.settings },
        import_react10.default.createElement(
          ControllerProvider,
          { controller: props.controller },
          import_react10.default.createElement(
            AccessabilityProvider,
            { accessability: props.accessability },
            import_react10.default.createElement(
              AnimationsProvider,
              { animations: props.animations },
              import_react10.default.createElement(
                IntersectionObserverProvider,
                null,
                import_react10.default.createElement(
                  AutoplayProvider,
                  { autoplay: props.autoplay },
                  import_react10.default.createElement(Orchestrator, { className: props.className, width: props.width, height: props.height, style: props.style }, props.children)
                )
              )
            )
          )
        )
      )
    )
  );
}

export {
  styleInject,
  useManager,
  useController,
  composeCssClasses,
  ConsoleLogger,
  useAnimations,
  useLayout,
  IntervalState,
  useAutoplay,
  HeroSlider
};
//# sourceMappingURL=chunk-WCB6AOK4.js.map
